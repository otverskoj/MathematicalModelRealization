import numpy as np

# Период, на которое составляется расписание в часах
Range = 24

# Количество временных интервалов
N_times = 24

# Шаг дискретизации диспетчерского расписания
delta_t = int(Range / N_times)

# Количество временных интервалов для расчёта временного интервала
N_tau = 60

# Шаг дискретизации временного интервала
delta_tau = delta_t / N_tau

# Структура производства
factory_struct = {
    "pipe": [6, 7, 8, 9, 10, 11, 12, 13, 21, 22, 23, 24, 26],
    "input": [0, 1, 2, 3, 4, 5],
    "pump": [],
    "tank": [14, 15, 16, 17, 18, 19, 20],
    "pipe_c": [],
    "tank_g": [27, 28, 29, 30],
    "stock": [31, 32]
}

N_inputs = len(factory_struct["input"])
N_stocks = len(factory_struct["stock"])
N_tanks_g = len(factory_struct["tank_g"])
N_pipes = len(factory_struct["pipe"])
N_tanks = len(factory_struct["tank"])

N_objects = N_inputs + N_stocks + N_tanks_g + N_pipes + N_tanks
N_all_tanks = N_tanks + N_tanks_g + N_stocks

# Двумерный массив связей между объектами
L = [(0, 6), (0, 7), (1, 8), (2, 9), (3, 10), (4, 11), (5, 12),
     (6, 13), (7, 14), (8, 15), (9, 19), (10, 16), (11, 17), (12, 18),
     (13, 20), (13, 21), (13, 22), (13, 23), (14, 20), (14, 21), (14, 22), (14, 23), (15, 20), (15, 21), (15, 22),
     (15, 23), (16, 20), (16, 21), (16, 22), (16, 23), (17, 20), (17, 21), (17, 22), (17, 23), (18, 20), (18, 21),
     (18, 22), (18, 23), (19, 20), (19, 21), (19, 22), (19, 23),
     (20, 24), (21, 24), (22, 24), (23, 24),
     (24, 25), (24, 26),
     (25, 27), (25, 28), (26, 29), (26, 30),
     (27, 31), (28, 31), (29, 32), (30, 32)]

# Количество связей между объектами
N_lines = len(L)

# Максимальная скорость потока между объектами
f_max = np.zeros((N_lines, N_times))

# Доля скорости потока от максимально возможной
x = np.zeros((N_lines, N_times))

# Скорость потока между объектами
f = np.zeros((N_lines, N_times))

# Поэлементное умножение
f = f_max * x

# Инициализирование массива f
for j in range(N_times):
    f[0][j] = 14.2
    f[1][j] = 14.2
    f[7][j] = 14.2
    f[8][j] = 14.2
    f[2][j] = 62
    f[9][j] = 62
    f[3][j] = 16.6
    f[10][j] = 16.6
    f[4][j] = 81.9
    f[11][j] = 81.9
    f[5][j] = 91.2
    f[12][j] = 91.2
    f[6][j] = 148.9
    f[13][j] = 148.9

for j in range(6, 16):
    f[14][j] = 1.4  # из 42 связи разделяем
    f[42][j] = 2.8
    f[18][j] = 1.4

    f[23][j] = 28.2
    f[43][j] = 28.2

    f[28][j] = 148.95
    f[32][j] = 148.95
    f[32][j] = 297.9

    f[36][j] = 152.5
    f[44][j] = 152.5

    f[46][j] = 480
    f[48][j] = 480

for j in range(16, 24):
    f[14][j] = 18
    f[42][j] = 18

    f[23][j] = 10.1
    f[39][j] = 10.1
    f[43][j] = 20.2

    f[28][j] = 146.7
    f[44][j] = 146.7

    f[33][j] = 32.55
    f[37][j] = 32.55
    f[45][j] = 65.1

    f[47][j] = 250
    f[50][j] = 250

# Время, затрачиваемое на пастпортизацию
pr = 3 * delta_t

# Массив связей из L, в которых первый элемент является tank_g, а второй - stock
lines_gs = [line for line in L if (line[0] in factory_struct["tank_g"]) and (line[1] in factory_struct["stock"])]

# Массив связей из L, в которых вторым элементом является tank_g
lines_in_tank_g = [line for line in L if line[1] in factory_struct["tank_g"]]

# Двумерный массив, хранящий начала проведения паспортизаций (с учетом,что паспортизация проходит на gs связи)
passport = np.zeros((len(lines_gs), N_times + pr))

# Инициализация паспортизации с 16:00 до 19:00 (не включительно) для ТР1 (элемент №27)
passport[0][16 + pr] = 1

# Двумерный массив, определяющий в каждый момент времени t проводится паспортизация в gs связи или нет
passport_in_t = np.zeros((len(lines_gs), N_times))

for line in lines_gs:
    for t in range(N_times):
        passport_in_t[lines_gs.index(line)][t] = passport[lines_gs.index(line)][:pr + t + 1].sum() - passport[
                                                                                                         lines_gs.index(
                                                                                                             line)][
                                                                                                     :t + 1].sum()  # разность количества единиц в массивах
        # passport_in_t[line][t] либо = 0, тогда в t не проводится паспортизация, либо 1 - проводится

# Ограничение на отсутствие приходов и откачки в/из товарный резервуар во время паспортизации
total = 0
Summa_passport_1 = 0;
Summa_passport_2 = 0
Summa_f_1 = 0;
Summa_f_2 = 0
for t in range(N_times):
    for line_in_g in lines_in_tank_g:  # в номере связи вторым объектом является товарный резервуар
        for line_gs in lines_gs:  # проходимся по связям ведущим из товарных резервуаров в стоки
            if line_gs[0] == line_in_g[
                1]:  # находим связь line_gs инцидентную связи line_in_g (находим связь gs у которой первый объект - товарный резервуар будет совпадать со вторым объектом у связи line_in_g ведущей в товарный резервуар)
                Summa_passport_1 += passport_in_t[lines_gs.index(line_gs)][t]
        Summa_f_1 += f[L.index(line_in_g)][t]
        total_1 = Summa_passport_1 * Summa_f_1  # либо в товарном резервуаре проходит паспортизация, либо в него закачивают бензин, нельзя одновременно, т.е. total_1 должен быть равен всегда нулю
        Summa_passport_1 = 0;
        Summa_f_1 = 0;

    for line_gs in lines_gs:  # в номере связи первым объектом является товарный резервуар
        Summa_passport_2 += passport_in_t[lines_gs.index(line_gs)][t]
        Summa_f_2 += f[L.index(line_gs)][t]
        total_2 = Summa_passport_2 * Summa_f_2  # либо в товарном резервуаре проходит паспортизация, либо из него выкачивают бензин, нельзя одновременно, т.е. total_2 должен быть равен всегда нулю
    Summa_passport_2 = 0;
    Summa_f_2 = 0
    total += total_1 + total_2

if total == 0:
    print("Ограничение на отсутствие приходов и откачки в/из товарный резервуар во время паспортизации выполняется")
else:
    print("Ограничение на отсутствие приходов и откачки в/из товарный резервуар во время паспортизации не выполняется")

# Условие на непересечение интервалов паспортизации у g-го товарного резервуара:
stop = False
Summa_passport = 0
for t in range(N_times):
    for line_gs in lines_gs:
        Summa_passport += passport_in_t[lines_gs.index(line_gs)][t]
    if Summa_passport > 1:
        stop = True
    Summa_passport = 0

if stop:
    print("Условие на непересечение интервалов паспортизации у g-го товарного резервуара не выполняется")
else:
    print("Условие на непересечение интервалов паспортизации у g-го товарного резервуара выполняется")

##
#### Проверка условий неотрицательности
##
print("\nПроверка условий неотрицательности:")
# Проверка того, что в массиве, задающем начала паспортизаций, должны ледать только 1 или 0
stop = False
for t in range(N_times + pr):
    for line_gs in range(len(lines_gs)):
        if passport[line_gs][t] != 0 and passport[line_gs][t] != 1:
            stop = True

if stop:
    print("В массиве, задающем начала паспортизаций, лежит что-то непохожее на 0 и 1")
else:
    print("В массиве, задающем начала паспортизаций лежат только единицы и нули")

# Проверка того, что значения в массиве x лежат в диапазоне от нуля до единицы
stop = False
for t in range(N_times):
    for line in range(N_lines):
        if x[line][t] < 0 or x[line][t] > 1:
            stop = True

if stop:
    print("Значения в массиве x выходят из диапазона от нуля до единицы")
else:
    print("Значения в массиве x лежат в диапазоне от нуля до единицы")

# Проверка, что в массиве, задающем начала паспортизаций, в диапозоне от нуля до pr, лежат только 0
stop = False
for t in range(pr):
    for line_gs in range(len(lines_gs)):
        if passport[line_gs][t] != 0:
            stop = True

if stop:
    print("В массиве, задающем начала паспортизаций, в диапозоне от нуля до pr, лежит что-то непохожее на 0")
else:
    print("В массиве, задающем начала паспортизаций, в диапозоне от нуля до pr, лежат только 0")