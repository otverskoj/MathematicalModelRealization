import numpy as np

# Период, на которое составляется расписание в часах
Range = 24

# Количество временных интервалов
N_times = 24

# Шаг дискретизации диспетчерского расписания
delta_t = int(Range / N_times)

# Количество временных интервалов для расчёта временного интервала
N_tau = 60

# Шаг дискретизации временного интервала
delta_tau = delta_t / N_tau

# Структура производства
factory_struct = {
    "pipe": [6, 7, 8, 9, 10, 11, 12, 13, 21, 22, 23, 24, 26],
    "input": [0, 1, 2, 3, 4, 5],
    "pump": [],
    "tank": [14, 15, 16, 17, 18, 19, 20],
    "pipe_c": [],
    "tank_g": [27, 28, 29, 30],
    "stock": [31, 32]
}

N_inputs = len(factory_struct["input"])
N_stocks = len(factory_struct["stock"])
N_tanks_g = len(factory_struct["tank_g"])
N_pipes = len(factory_struct["pipe"])
N_tanks = len(factory_struct["tank"])

N_objects = N_inputs + N_stocks + N_tanks_g + N_pipes + N_tanks
N_all_tanks = N_tanks + N_tanks_g + N_stocks

# Двумерный массив связей между объектами
L = [(0, 6), (0, 7), (1, 8), (2, 9), (3, 10), (4, 11), (5, 12),
     (6, 13), (7, 14), (8, 15), (9, 19), (10, 16), (11, 17), (12, 18),
     (13, 20), (13, 21), (13, 22), (13, 23), (14, 20), (14, 21), (14, 22), (14, 23), (15, 20), (15, 21), (15, 22), (15, 23), (16, 20), (16, 21), (16, 22), (16, 23), (17, 20), (17, 21), (17, 22), (17, 23), (18, 20), (18, 21), (18, 22), (18, 23), (19, 20), (19, 21), (19, 22), (19, 23),
     (20, 24), (21, 24), (22, 24), (23, 24),
     (24, 25), (24, 26),
     (25, 27), (25, 28), (26, 29), (26, 30),
     (27, 31), (28, 31), (29, 32), (30, 32)]

# Количество связей между объектами
N_lines = len(L)

# Максимальная скорость потока между объектами
f_max = np.zeros((N_lines, N_times))

# Доля скорости потока от максимально возможной
x = np.zeros((N_lines, N_times))

# Скорость потока между объектами
f = np.zeros((N_lines, N_times))

# Поэлементное умножение
f = f_max * x

# Инициализирование массива f
for j in range(N_times):
  f[0][j] = 14.2
  f[1][j] = 14.2
  f[7][j] = 14.2
  f[8][j] = 14.2
  f[2][j] = 62
  f[9][j] = 62
  f[3][j] = 16.6
  f[10][j] = 16.6
  f[4][j] = 81.9
  f[11][j] = 81.9
  f[5][j] = 91.2
  f[12][j] = 91.2
  f[6][j] = 148.9
  f[13][j] = 148.9

for j in range(6, 16):
  f[14][j] = 0.7 #из 42 связи разделяем
  f[42][j] = 1.4
  f[18][j] = 0.7

  f[23][j] = 28.2
  f[43][j] = 28.2

  f[28][j] = 148.95
  f[32][j] = 148.95
  f[44][j] = 297.9

  f[37][j] = 152.5
  f[45][j] = 152.5

  f[46][j] = 480
  f[48][j] = 480

for j in range(16, 24):
  f[14][j] = 18
  f[42][j] = 18

  f[23][j] = 10.1
  f[39][j] = 10.1
  f[43][j] = 20.2

  f[28][j] = 146.7
  f[44][j] = 146.7

  f[33][j] = 32.55
  f[37][j] = 32.55
  f[45][j] = 65.1

  f[47][j] = 250
  f[50][j] = 250


# Множество пар связей, промежуточный объект которых является товарным резервуаром
D_g = []

# Заполнение D
for i in range(len(L)):
    if L[i][1] in factory_struct["tank_g"]:
        for j in range(i, len(L)):
            if L[i][1] == L[j][0]:
                D_g.append((i, j))

# Ограничение на запрет наполнение товарного резервуара в момент его отгрузки и ограничение на запрет отгрузки в момент наполнения товарного резервуара
result = 0;
for t in range(N_times):
    #Out = 0
    for item in D_g:
        # Номер объекта на технологической схеме
        #obj = L[item[0]][1]
        #if obj == i:
          #need_connect = item[0]
          #Out += f[item[1]][t]  # Это не нужно, т.к. у товарных резервуаров только один вход и выход
      result += f[item[0]][t] * f[item[1]][t]
    if result != 0:
      print("Ограничение на запрет наполнение товарного резервуара в момент его отгрузки и ограничение на запрет отгрузки в момент наполнения товарного резервуара не выполняются")

if result == 0:
  print("Ограничение на запрет наполнение товарного резервуара в момент его отгрузки и ограничение на запрет отгрузки в момент наполнения товарного резервуара выполняются")

# Массив максимальной пропускной способности в i-ой трубе
V_max = np.zeros(N_objects)
for i in range(N_objects):
    if i == 25:
        V_max[i] = 480
    elif i == 26:
        V_max[i] = 250
    else:
        V_max[i] = 500

# Массив минимальной пропускной способности в i-ой трубе
V_min = np.zeros(N_objects)

# Ограничения входящего и выходящего потока в объект
stop = False
Summa_f_1 = 0; Summa_f_2 = 0
for t in range(N_times):
  for i in range(N_objects):
    for line in range(N_lines):
      if i == L[line][0]: #в номере связи первым объектом является рассматриваемый объект
        Summa_f_1 += f[line][t]
      if i == L[line][1]: #в номере связи вторым объектом является рассматриваемый объект
        Summa_f_2 += f[line][t]
    if (Summa_f_1 > V_max[i] or Summa_f_1 < V_min[i]) or (Summa_f_2 > V_max[i] or Summa_f_2 < V_min[i]):
      stop = True
    Summa_f_1 = 0; Summa_f_2 = 0

if stop:
  print("Выход за допустимые границы пропускной способности")
else:
  print("Ограничения входящего и выходящего потока в объект выполняются")